# Phase 1: 챌린지 참여 - `EscrowCreate`를 통한 참가비의 안전한 예치

   * 사용자 시나리오:
      사용자가 특정 챌린지에 '참여하기' 버튼을 누르고 참가비를 지불합니다.

   * XRPL 상호작용:
       1. 이때 참가비는 저희 중앙 지갑으로 직접 전송되는 것이 아니라, XRPL의 `EscrowCreate` 트랜잭션이 생성됩니다.
       2. Escrow의 조건(Condition)에는 '챌린지 종료 시간'과 '운영 지갑의 서명'이 포함되어, 이 두 조건이 모두 충족되어야만 자금이 해제될 수 있도록 설정됩니다.
       3. 이 트랜잭션이 성공하면, 참가비는 챌린지가 진행되는 동안 XRPL 네트워크 상에 안전하게 동결(Lock)됩니다.

   * 핵심 가치:
      운영 주체의 파산이나 횡령과 같은 중앙화된 위험(Centralized Risk)으로부터 사용자의 자산을 원천적으로 보호하며, 플랫폼에 대한 초기 신뢰를 확보합니다.

  ---

# Phase 2: 챌린지 종료 - 이벤트 기반 아키텍처를 통한 자동화된 정산 트리거

   * 시스템 시나리오:
      챌린지 종료 시간이 되면, 백엔드 시스템에서 ChallengeCompletedEvent가 발행됩니다.

   * XRPL 상호작용:
       1. 이 이벤트는 `XRPLEventListener` 에 의해 감지되며, XRPL과의 온체인 상호작용을 시작하는 '트리거' 역할을 합니다.
       2. 이 단계는 비즈니스 로직(챌린지 관리)과 블록체인 로직(정산)을 분리하는 중요한 지점입니다. XRPLEventListener는 이 이벤트를 받아 필요한 모든 데이터를(참여자 목록, 성공률 등)
          집계하여 다음 단계로 전달합니다.

   * 핵심 가치:
      이벤트 기반 아키텍처를 통해 관심사를 명확히 분리(SoC)하여, 향후 새로운 보상 규칙이나 챌린지 종류가 추가되더라도 XRPL 관련 코어 로직의 수정 없이 유연하게 확장할 수 있는 구조를
  만듭니다.

  ---

# Phase 3: 일괄 정산 및 환급 - `Batch`를 활용한 `EscrowFinish`와 `Payment`

   * 시스템 시나리오:
      XRPLEventListener는 집계된 데이터를 바탕으로, 모든 참여자의 Escrow를 정산하고, 기준을 충족한 참여자에게 환급금을 지급합니다.

   * XRPL 상호작용 (두 가지 로직이 순차적으로 실행):
       1. A. Escrow 일괄 완료:
           * XRPLServiceImpl의 `completeBatchEscrow` 메소드가 호출됩니다.
           * 이 메소드는 for 루프를 돌며 각 참여자에 대한 `EscrowFinish` 트랜잭션을 순차적으로 생성하고 서명하여 XRPL 네트워크에 제출합니다.
           * 여러 트랜잭션을 연속으로 보내기 위해, 계정의 시퀀스(Sequence) 번호를 코드 레벨에서 직접 관리(currentSequence.plus(UnsignedInteger.ONE))하여 처리 효율을 극대화합니다.

       2. B. 환급금 일괄 지급:
           * 이어서, 인증 성공률 70%를 넘은 사용자들에게 참가비의 일부를 환급하기 위해 `sendBatchPayment` 메소드가 호출됩니다.
           * 이 로직 역시 for 루프와 시퀀스 수동 관리를 통해 다수의 `Payment` 트랜잭션을 생성하여 여러 명에게 동시에 XRP를 전송합니다.

   * 핵심 가치:
      수백, 수천 건의 트랜잭션이 발생하더라도 수동 개입 없이 몇 초 안에 모든 정산과 환급을 완료하여 운영 비용을 획기적으로 절감하고, 사용자에게 빠르고 투명한 보상 경험을 제공합니다.

  ---

# Phase 4: 성취 증명 - `Credential` 시뮬레이션을 통한 온체인 기록

   * 시스템 시나리오:
      모든 정산이 완료된 후, 챌린지 완주자에게 그들의 성취를 증명하는 영구적인 기록을 남깁니다.

   * XRPL 상호작용:
       1. XRPLServiceImpl의 `createCredential` 메소드가 호출됩니다.
       2. 현재 xrpl4j 라이브러리의 한계로, 저희는 `Payment` 트랜잭션에 1 drop의 최소 금액과 함께, `Memo` 필드에 {'type': 'ChallengeCompletion', 'challengeId': 123, ...} 와 같은 JSON
          형식의 데이터를 담아 보내는 방식으로 Credential을 시뮬레이션합니다.
       3. 이 트랜잭션은 XRPL 원장에 영구적으로 기록되므로, 해당 사용자가 챌린지를 완료했다는 사실을 누구나 검증할 수 있는 온체인 증거(On-chain Proof)가 됩니다.

